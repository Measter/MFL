import std::term

struct lang(string) String {
    field length u64,
    field pointer u8&,
}

struct SplitResult {
    field split bool,
    field remainder String,
    field prefix String,
}

// Splits the given string at the first instance of the given
// character. Remaining string does not include the split char.
proc split_front [
    String
    u8  // Char to split on
] to [
    SplitResult
] {
    memory str { String }
    memory char { u8 }

    // [string, char]
    if over xtrd(length) 0= {
        drop

        false swap dup pack(SplitResult)
    } else {
        char!
        str!

        0(u64) while 
            dup str xtrd(length) <
            if dup { over str xtrd(pointer)+ @ char@ != and }
        {
            // [counter]
            1+
        }
        // We're either at the end of the string, or found our character.

        // [idx]
        if dup str xtrd(length) = {
            // Reached the end of the string
            drop
            false str@ "" pack(SplitResult)
        } else {
            // We found the split character!

            // Construct the prefix
            str xtrd(pointer)
            // [idx, ptr]
            over
            // [idx, ptr, len]
            swap pack(String) swap

            // [prefix, idx]
            // Construct the remander.
            str@ unpack
            // [prefix, idx, len, ptr]
            over(2)+ 1+
            rev(3) - 1-
            swap pack(String)
            
            swap true rot(3>1)
            // [flag, remainder, prefix]
            pack(SplitResult)
        }
    }
}

proc is_whitespace [u8] to [bool] {
    dup 32=         // Space
    over 9= or      // Tab
    over 10= or     // Line Feed
    over 12= or     // Form Feed
    over 13= or     // Carriage return
    swap drop
}

proc trim_start [String] to [String] {
    memory str { String }
    str!
    
    0 while dup str xtrd(length) < {
        if str xtrd(pointer)@ is_whitespace {
            str@ unpack
            1+ str insd(pointer)
            1- str insd(length)
        } else {
            // Can't break loops at the moment, so this will do.
            drop
            str@ return
        }
        1+
    } drop

    str@
}


proc trim_end [String] to [String] {
    memory str { String }
    str!

    if str xtrd(length) 0= { str@ return }

    str xtrd(length) 1- while dup 0> {
        if dup str xtrd(pointer) +@ is_whitespace {
            str xtr(length) 1- swap insd(length)
        } else {
            // Cant break loops at the moment.
            drop str@ return
        }
        1-
    } drop

    str@
}

proc trim [String] to [String] { 
    trim_start trim_end
}

proc remove_start[String u64] to [String] {
    if over xtrd(length) over< {
        "Cannot trim " std::term::ewrite
        std::term::ewrite_ui
        " from string of length "
        xtr(length) std::term::ewrite_ui_ln
        exit
    }

    swap xtr(length) over(2)- swap ins(length)
    xtr(pointer) rot(3<1)+ swap ins(pointer)
}