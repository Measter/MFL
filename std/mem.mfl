import lib::Result
import lib::ErrNo
import lib::SimpleResult

struct Slice(T) {
    pointer: T*,
    length: u64,

    proc fill(T) [
        var val: T,
        var this: Slice(T),
    ] to [] {
        0 while dup this.length@ < {
            val@ over this#!
            1+
        } drop
    }

    proc(track_caller) copy_from(T) [
        var src: Slice(T),
        var this: Slice(T),
    ] to [] {
        cond {
            src.length@ this.length@ != {
                "Mismatched length in copy_from - src: " lib::term::ewrite
                src.length@ lib::term::ewrite_ui
                " dst: " lib::term::ewrite
                this.length@ lib::term::ewrite_ui_ln
                exit(1)
            }
        }

        0 while dup this.length@ < {
            dup src#@
            over this#!
            1+
        } drop
    }
}

struct OwnedSlice(T) {
    pointer: T*,
    length: u64,

    proc to_slice(T) [OwnedSlice(T)] to [Slice(T)] {
        unpack Slice
    }
}

proc(lang(alloc)) alloc(T) [
    u64 // Number of Ts to allocate for
] to [Result(OwnedSlice(T), ErrNo)] {
    dup sizeof(T) * // We need the number of bytes to allocate, not the number of Ts.
    lib::clib::malloc

    cond {
        isnull {
            drop lib::clib::get_errno ErrNo::from_int
            Result::Err(OwnedSlice(T), ErrNo)
        }
        else {
            cast(T*) swap OwnedSlice
            Result::Ok(OwnedSlice(T), ErrNo)
        }
    }
}

proc(lang(free)) free(T) [OwnedSlice(T)] to [] {
    xtrd(pointer) cast(u8*) lib::clib::free
}
